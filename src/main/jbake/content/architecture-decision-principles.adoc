= Making reasonable technology decisions
:jbake-type: page
:jbake-status: published
:jbake-date: 2023-11-12
:jbake-tags: desgin pattern, architecture, java, kiss, agile, decision making, technology
:jbake-description: Describe how we are making architectural decisions
:jbake-disqus_enabled: true
:jbake-disqus_identifier: d23e2d10-c1a6-11ed-8bd8-3b33f0bea9fd
:idprefix:

Why do we think having aligned architectural principles is a good idea...

== The Problem

Let's think about what could happen when you take two developers, and lock them up in a room until they have a consensus on what is the best programming language they should pick up for the next project.

From my experience that could end up not so nice. Without getting deeper into how they would look like after 10 hours, I would bet they will not find consensus in quite many cases. We guess that the reason is, that they will likely argue more preference-based which will turn out to get personal pretty fast.

https://www.meeteor.com/post/principle-based-decision-making[Read this to know why we think so].

So we want to provide our members with principles that guide them through a smooth decision-making process, with the best result for Dancier.

== The Principles by Categories

=== General
[cols="1,2,6"]
|===
|Id|Name|Description

|G1
|Embrace Uncertainty
|Uncertainty is not a problem to be solved,
but an opportunity to uncover options in the face of the unknown.
Rather than seeking false precision through exhaustive upfront analysis,
this principle encourages a Start Less, Finish More mindset while still demanding a clear vision to follow.
It emphasizes documenting assumptions, creating minimal viable strategies
and iteratively adapting plans based on evolving insights.

|G2
|Delay Design Decisions
|Delay design decisions until they are absolutely necessary.
Decisions should be made at the last responsible moment, fostering a culture of experimentation.
This will gather new insights that can be used to iteratively design the architecture.
There is no point in designing and implementing capabilities upfront that may never be used
- it is a waste of time and resources.

|G3
|Design for Change
|The architecture should be designed to support change, not to prevent it.
This means that the architecture should be loosely coupled, modular, and extensible.
It should be easy to add new capabilities and to change existing ones.
The architecture should be designed to support the ability to experiment and learn.

|G4
|Principle of Least Surprise
|Build software and design the architecture such that it doesn't surprise users or fellow developers.
When making decisions, prioritize predictability and ease of use over cleverness and novelty.
This general principle can be applied to many aspects,
such as making architectural decisions as well as building a clear UI for the end user.

|G5
|Low Coupling, High Cohesion
|Strive for low coupling, where modules minimize dependencies on each other,
ensuring changes in one module have minimal impact on others.
Simultaneously, pursue high cohesion within modules,
ensuring closely related code elements work together seamlessly,
fostering maintainability, readability and efficient development.

|G6
|Cohesive Code Structuring
|Build a cohesive structure for code not only based on technical distinctions
but primarily on the business domain or features they serve.
Files that are used for providing the same features should be relatively close by,
sharing the same parent directory / module where possible.
This approach enhances code cohesion, allowing developers working on a particular feature
to locate and modify related files efficiently.

|G7
|Compliance with Law
|Compliance with all relevant laws and regulations.

|G8
|Non-proliferation of Technology
|Technical diversity will be controlled to reduce complexity.

|G9
|Keep it simple stupid (KISS)
a|Based on our interpretation of
https://en.wikipedia.org/wiki/Agile_software_development[Agile Development]
we think that we should choose the https://en.wikipedia.org/wiki/KISS_principle[simplest] approach to tackle a task. +

Particularly, we always try to avoid optimizing things before it turns out
that optimization is needed (https://ubiquity.acm.org/article.cfm?id=1513451[see Donald Knuth]).
This applies, in the same way, to _small_ things eg.

* optimizing algorithms like SQL queries
* choosing frameworks for persistence, offering rest endpoints, frontend frameworks
* infrastructural topics like VCS build system

As well as it applies to "bigger" things eg.

     * Deciding architectural things like using CQRS
     * Using microservices vs. putting things into a monolith

|G10
|Shared Resources
|Solutions will seek to maximum sharing of
resources such as network, computing, storage
and data.

|G11
|Quality
|A minimum standard of quality will be maintained despite time-to-market concerns.

|G12
|Favor what is proven
|     Default for standard options. Eg. when there are several similar web frameworks, go for the more prominent one. Because we expect that:
      * we are getting more support from other developers if we run into problems
      * expect more support from the upstream project itself, and also the project itself will exist for a longer time
      * have better tooling support (if applicable)
      * have it easier to find more developers

|G13
| Match techniques with skills of core team members
| The chosen technique should be either already known by the team (or part of the team) or the team must be willing to learn it.
|===

=== Data

[cols="1,2,6"]
|===
|Id|Name|Description

|D1
|Data Confidentiality
|Confidential data must be protected.

|D2
|Master Data
|All data will have a golden copy.

|===

=== General Software Architektur

[cols="1,2,6"]
|===
|Id|Name|Description

|SA1
|Separation of Concerns
|It will be possible to change a component with
minimal impact on other components.

|SA2
|Loosely Coupled Services
|Services will be loosely coupled (producers loosely coupled with consumers).

|SA3
|Service Abstraction
|Services will hide their underlying implementation details.
|===

=== Usability

[cols="1,2,6"]
|===
|Id|Name|Description

|U1
|Easy of Use
|User interfaces will be as simple and intuitive as possible.

|U2
|Consistent Navigation
|Content and navigation will be consistent.

|U3
|Predictable Interface
|User actions should have predictable results.
|===



=== Process

[cols="1,2,6"]
|===
|Id|Name|Description

|P1
|Continuous Improvement
|Processes will be designed from the ground up to support continuous improvement.
|===

=== Business

[cols="1,2,6"]
|===
|Id|Name|Description

|B1
|Response to Customers
|Customer requests will be addressed promptly.

|B2
|Quality First
|Honest errors are not punished and stopping to fix problems is encouraged.

|===

=== Applications

[cols="1,2,6"]
|===
|Id|Name|Description

|A1
|Platform Independent, Open Standards
|Applications that support open standards are
preferred.

|A2
|Minimum Feature Set
|Features add complexity and should be kept to a minimum (avoid bells and whistles and systematic handling of improbable exceptions).

|A3
|Bleeding Edge
|Experimental or early-release technologies will not be used unless they are critical to competitive advantage.

|===

