= Making reasonable technology decisions
:jbake-type: page
:jbake-status: published
:jbake-date: 2023-03-02
:jbake-tags: desgin pattern, architecture, java, kiss, agile, decision making
:jbake-description: Describe how we are making technical decisions
:jbake-disqus_enabled: true
:jbake-disqus_identifier: d23e2d10-c1a6-11ed-8bd8-3b33f0bea9fd
:idprefix:

Why do we think having aligned architectural principles is a good idea...

== The Problem

Let's think about what could happen when you take two developers, and lock them up in a room until they have a consensus on what is the best programming language they should pick up for the next project.

From my experience that could end up not so nice. Without getting deeper into how they would look like after 10 hours, I would bet they will not find consensus in quite many cases. We guess that the reason is, that they will likely argue more preference-based which will turn out to get personal pretty fast.

https://www.meeteor.com/post/principle-based-decision-making[Read this to know why we think].

So we want to provide our members with principles that guide them to a smooth decision-making process, with the best result for Dancier.

== The Principles by Categories

=== General
[cols="1,2,6"]
|===
|Id|Name|Description

|G1
|Compliance with Law
|Compliance with all relevant laws and regulations.

|G2
|Non-proliferation of Technology
|Technical diversity will be controlled in order to
reduce complexity.

|G3
|Keep it simple stupid (KISS)
a|Based on our interpretation of
https://en.wikipedia.org/wiki/Agile_software_development[Agile Development]
we think that we should choose the https://en.wikipedia.org/wiki/KISS_principle[simplest] approach to tackle a task. +

Particularly, we always try to avoid optimizing things before it turns out
that optimization is needed (https://ubiquity.acm.org/article.cfm?id=1513451[see Donald Knuth]).
This applies, in the same way, to _small_ things eg.

* optimizing algorithms like SQL queries
* choosing frameworks for persistence, offering rest endpoints, frontend frameworks
* infrastructural topics like VCS build system 

As well as it applies to "bigger" things eg.

     * Deciding architectural things like using CQRS
     * Using microservices vs. putting things into a monolith

|G4
|Shared Resources
|Solutions will seek to maximum sharing of
resources such as network, computing, storage
and data.

|G5
|Quality
|A minimum standard of quality will be maintained despite time to market concerns.

|G6
|Favor what is proven
|     Default for standard options. Eg. when there are several similar web frameworks, go for the more prominent one. Because we expect that:
      * we are getting more support from other developers if we run into problems
      * expect more support from the upstream project itself, and also the project itself will exist for a longer time
      * have better tooling support (if applicable)
      * have it easier to find more developers
 
|G7
| Match techniques with skills of core team members
| The chosen technique should be either already known by the team (or part of the team) or the team must be willing to learn it.
|===

=== Data

[cols="1,2,6"]
|===
|Id|Name|Description

|D1
|Data Confidentiality
|Confidential data must be protected.

|D2
|Master Data
|All data will have a golden copy.

|===

=== General Software Architektur

[cols="1,2,6"]
|===
|Id|Name|Description

|SA1
|Separation of Concerns
|It will be possible to change a component with
minimal impact on other components.

|SA2
|Loosely Coupled Services
|Services will be loosely coupled (producers loosely coupled with consumers).

|SA3
|Service Abstraction
|Services will hide their underlying implementation details.
|===

=== Usability

[cols="1,2,6"]
|===
|Id|Name|Description

|U1
|Easy of Use
|User interfaces will be as simple and intuitive as possible.

|U2
|Consistent Navigation
|Content and navigation will be consistent.

|U3
|Predictable Interface
|User actions should have predictable results.
|===



=== Process

[cols="1,2,6"]
|===
|Id|Name|Description

|P1
|Continuous Improvement
|Processes will be designed from the ground up to support continuous improvement.
|===

=== Business

[cols="1,2,6"]
|===
|Id|Name|Description

|B1
|Response to Customers
|Customer requests will be addressed promptly.

|B2
|Quality First
|Honest errors are not punished and stopping to fix problems is encouraged.

|===

=== Applications

[cols="1,2,6"]
|===
|Id|Name|Description

|A1
|Platform Independent, Open Standards
|Applications that support open standards are
preferred.

|A2
|Minimum Feature Set
|Features add complexity and should be kept to a minimum (avoid bells and whistles and systematic handling of improbable exceptions).

|A3
|Bleeding Edge
|Experimental or early-release technologies will not be used unless they are critical to competitive advantage.

|===

