[[section-runtime-view]]
== Runtime View

=== E-Mail Sending (not the Info-Mail)

We are describing how _some_ System can send an arbitrary mail to some arbitrary recipient.

From a high level perspective it looks like:

[plantuml, send-mail, svg]
....
@startuml

autonumber

actor user
participant "Some System" as ss
participant kikeriki
participant "SMTP-Server" as smtp

ss -> kikeriki: send E-Mail Command
kikeriki -> smtp: send the email

@enduml
....

1. The E-Mail Command that some system sends... +
 contains the complete Mail (as Text) and its recipients
1. Kikeriki send the E-Mail via the SMTP-Server to the recipients

==== More detailed look on how kikeriki send the E-Mail

[plantuml, send-mail-kikeriki, svg]
....
@startuml

autonumber

participant "Some System" as ss
box kikeriki #LightBlue
participant "Kafka-Adapter" as ka
participant "Application Event" as ae
participant "Outbox"
participant "Outbox Job" as oj
end box
participant "SMTP-Server" as smtp

ss -> ka: send mail command
ka -> ae : throw application event
ae -> Outbox: store

loop for each stored mail
  oj -> Outbox : get Mail
  Outbox -> smtp : send Mail
end

@enduml
....

1. send mail command reaches kikeriki
1. command is being mapped +
 Kikeriki uses https://docs.spring.io/spring-framework/reference/testing/testcontext-framework/application-events.html[Spring Application Events] to couple it's distince modules. The incoming Mail-Command from Kafka is being mapped into a an Application Event, that is being thrown.
1. The Mail Command is stored into an outbox +
   The Mail Command ist handled by storing it into on outbox table. (when this fails, also the Kafka-Adapter will try to reconsume the event until this is successfull)
1. A Job polls the outbox +
  Every two seconds the Job looks for more Mails to be send.


=== Info-Mail Sending

=== Process how Recommendations are being computed

When a user changes his profile, this is likey to invalidate all score he has in relation to other dancers.

It starts with a change of the profile...
[plantuml, change-profile, svg]
....
@startuml

actor user
participant dancer
database S3

user -> dancer : change profile
dancer -> S3 : change profile

@enduml
....

Now it is time for the recommendation to compute all new recommendations. This is implemented as a batch job, that runs once a night.

[plantuml, compute-recommendations, svg]
....
@startuml

database S3
participant recommendation

loop for all profiles
    recommendation -> S3 : import into a local database
end

recommendation -> recommendation: greedy computes all dancer pairs within 200km
note left
    and store them locally
    while overwriting all
    previously computed pairs
end note

loop for each pair
    recommendation -> recommendation: compute score
    note left
        store the score
        locally
    end note
end
@enduml
....

Now the recommendation service can return for each dancer, a list of all dancers within a distance of 200km together with the computed <<score>>.
